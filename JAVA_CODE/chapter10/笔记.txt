目录
    类变量和类方法
    理解main方法语句
    代码块
    单例设计模式
    final关键字
    抽象类
    接口
    内部类

类变量和类方法
    类变量
        传统方法解决存在的问题：
            1.count是一个独立于对象的变量
            2.以后访问count很麻烦
            3.引出静态变量
        类变量布局分析
            不论类变量/静态变量放在哪里，其都是被同一个类所有对象共享，所以不影响使用
            jdk8以前，在方法区，jdk8之后放在堆，放在堆里面这个类对应的class对象，所以类加载时就生成了，
            没有对象实例也可以访问，反射...

        定义
            类变量也叫静态变量，时该类的所有对象共享的变量，任何一个该类的回想访问它时，取到的都是相同的值，修改也是。
        语法
            访问修饰符 static 数据类型 变量名;
            static 访问修饰符 数据类型 变量名;
            类名/对象名.类变量名，推荐使用类名.类变量名
            访问类变量也遵循相关的访问权限

        类变量细节：
            1.什么时候需要：所有对象公用一个属性，就可以考虑使用静态变量
            2.类变量是所有对象共用的属性，而实例变量是每个对象独有的
            3.加上static才是类变量，否则是普通变量
            4.类变量可以通过类名访问，也可以通过对象名访问，推荐用类名
            5.实例变量不能用过类名访问
            6.类变量在加载是就初始化了，也就是说即使没有创建对象，只要类加载了就可以使用类变量了
            7.类变量的生命周期是随类的加载开始，随类的消亡和销毁

    类方法
        也叫静态方法，形式同上，访问也是同上
        //好处，不创建实例也可以调用某个方法，即当工具使用
        经典使用场景：当方法中不涉及到任何和对象相关的成员，则可以设计成静态方法提高开发效率
        细节：
            1.类方法和普通方法都是随类的加载而加载，将结构信息存在方法去，类方法中无this的参数
            2.类方法可以通过类名或对象名调用
            3.普通对象不能通过类名调用
            4.类方法不允许使用和对象有关的关键字，不如this和super
            5.静态方法只能访问静态变量或方法
            6.普通成员方法，即可以访问静态方法，也可以访问非静态方法

理解main方法语句
    public static void main(String[] args) {

    }
    深入理解main方法：
        1.main方法是虚拟机调用的
        2.java虚拟机需要调用main方法，因此，该方法权限必须是public
        3.java虚拟机在执行main方法时不必创建对象，因此方法必须是static
        4.该方法接收String类型数组，该数组保存执行java命令时传递给所运行的类的参数，

    main方法可以直接调用main方法所在类中的静态方法和属性
    但是不能直接访问类中的非静态成员，必须创建一个实例对象后才能通过对象访问类中静态成员

代码块
    又称初始化块，属于类中的成员，类似方法，将逻辑语句封装在方法体中，用{}包围起来
    但与方法不同，没有方法名，返回值，没有参数，只有方法体，而且不用通过对象或类显示调用，二十加载类时，或创建对象时隐式调用
    基本语法
        [修饰符]{
            代码
        };
        说明：修饰符要写只有static ，分两种静态或非静态，即加不加static，逻辑语句可以为任何逻辑语，；可以写也可以省略
    好处：相当于另一种形式的构造器，如果多个构造器中都有重复的语句，可以抽取到代码块中，提高代码复用性
    细节：
        1.static修饰称为静态代码块，作用是对类进行初始化，随着类的加载而加载执行，且只执行一次，如果是普通代码块，每创建一个对象，就执行
        2.类什么时候被加载，创建对象实例；创建子类对象实例，父类也会被加载；使用类的静态成员即静态属性和方法
        3.普通代码块在创建对象实例时，会被隐式的调用，被创建了一次，就会调用一次，如果使用类的静态成员时，普通代码块并不会被执行
        4.创建一个对象时，在一个类，调用顺序是：
            调用静态代码块，静态属性初始化 -- 两者调用优先级一致，如果有多个，则按他们定义顺序调用
            调用普通代码块和普通属性的初始化 -- 两者调用优先级一致，如果有多个，则按他们定义顺序调用
            调用构造方法
        5.构造器的最前面隐含了super()和调用本类普通代码块，静态相关代码块，属性初始化，在加载类时，就执行完毕，因此时优先于构造器和普通代码块
        6.创建一个子类时，他们的静态代码块，普通属性初始化，构造器调用顺序如下：
            父类的静态代码块和静态属性 -- 优先级一致，按照定义顺序执行
            子类的静态代码块和静态属性 -- 优先级一致，按照定义顺序执行
            父类的普通代码块和普通属性初始化 -- 优先级一致，按照定义顺序执行
            父类构造方法
            子类的普通代码块和普通属性初始化 -- 优先级一致，按照定义顺序执行
            子类的构造方法
            （面试题）***
        7.静态代码块只能直接调用静态成员，普通代码块可以调用任意成员

单例设计模式
    静态方法和属性的经典使用
    设计模式是指在大量的实践中总结和理论化之后优选的代码结构，以及解决问题的思考方式等
    所谓单例模式，采取一定方法保证整个软件系统中，对某个类之恶能存在一个实例对象，并且该类只提供一个取得其对象实例的方法
    java.lang.Runtime就是单例
    两种：饿汉式；懒汉式
    具体步骤：
        1.构造器私有化 -- 防止用户直接new
        2.类的内部创建对象
        3.向外暴露一个静态的公共方法 getInstance
        4.代码实现
    饿汉式：在静态变量初始化，方法返回。不存在线程安全问题
    懒汉式：静态方法中new。不存在浪费资源的可能

final关键字
    可以修饰类、属性、方法、局部变量
    用处：
        1.不希望被继承，用final
        2.不希望父类的某个方法被重写，用final
        3.不希望类中某个属性值被修改，用final
        4.不希望某个局部变量被修改，用final

    细节：
        1.final修饰的属性又叫常量，一般用XX_XX_XX来命名
        2.final修饰的属性定义时必须赋初值，并且不能再修改，赋值可以在如下位置之一
            定义时
            构造器中
            代码块中
        3.如果final修饰的属性是静态的，赋值只能是定义是和静态代码块，不能在构造器中赋值
        4.final类不能继承，但是可以实例化对象
        5.如果类不是final类，凡是含有final方法，则该方法虽然不能重写，但是可以被继承
        6.一般来说，如果一个类已经是final类了，就没必要将方法修饰成final方法
        7.final不能修饰构造器
        8.final和static往往搭配使用，效率更高，不会导致类加载，底层编译器做了优化
        9.包装类(Integer Double Float Boolean都是final类),String也是final类

抽象类
    //父类方法不确定性，考虑将该方法设计为抽象方法abstract，即没有方法体
    //一个类中有抽象方法，则类也应是抽象类
    介绍
        1.用abstract修饰一个类时，就是抽象类
        2.用abstract修饰一个方法，就是抽象方法，即没有方法体
        3.抽象类的价值更多作用时在于设计，让子类继承并实现抽象类
        4.抽象类在框架和设计模式中使用较多，考官爱问
    细节：
        1.抽象类不能实例化
        2.抽象类不一定要包含abstract方法，也就是说抽象类可以没有abstract方法，还可以有实现的方法
        3.但抽象类包含了abstract方法就必须声明类为abstract
        4.abstract只能修饰类和方法，不能修饰属性和其他
        5.抽象类可以有任意成员
        6.抽象方法不饿能有主体
        7.如果继承了抽象类，则必须实现抽象类的所有方法，除非他自己也声明为abstract类
        8.抽象方法不能使用private final static修饰，因为这些关键字都是与重写相违背的
    抽象类最佳实践 - 模板设计模式
        需求：
            有多个类，完成不同的任务
            要求能够得到各自完成任务的时间
            编写程序实现
接口
    接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，根据具体情况把这些方法写出来
    interface 接口名{
        //属性
        //方法
    }
    class 类名 implement 接口{
        自己的属性；
        自己的方法；
        必须实现的接口的抽象方法
    }
    小结：
        jdk7之前，接口所有方法都没有方法体，即都是抽象方法
        jdk8之后，接口可以有静态方法，默认方法default修饰，也就是说接口中可以有方法的具体实现
    应用场景
        略。自己体会吧
    细节：
        1.接口不能被实例化
        2.接口中所有的方法都是public方法，接口中抽象方法，可以不用abstract修饰
        3.普通类实现接口，就必须将该接口所有方法都实现
        4.抽象类实现接口，就不用实现接口的方法
        5.同一个类可以实现多个接口
        6.接口中的属性只能是final的，而且是public static final 修饰
        7.接口中属性的访问形式：接口名.属性名
        8.一个接口不能继承其他的类，但可以继承多个别的接口
        9.接口修饰符只能是public和默认，这点和类的修饰符是一样的
    继承和接口
        实现接口 对单继承的补充
        继承主要是解决代码的复用性和维护性，接口主要用于设计规范
        接口比继承更灵活，接口只需满足like - a的关系
        接口一定程度上实现代码的解耦
    接口多态特性

    接口多态传递

内部类
    一个类的内部有完整嵌套了另一个类。
    类的五大成员：属性、方法、构造器、代码块、内部类
    内部类最大特点就是可以直接访问私有属性，并且体现类与类的包含关系
    class Outer {
        class Inner {

        }
    }
    class Other {

    }

    四种内部类
    定义在外部类局部位置 - 比如方法内
        局部内部类 - 有类名
            1.可以直接访问外部类的所有成员包括私有
            2.不能添加访问修饰符，因为他的低位就是一个局部变量，局部变量能使用修饰符，但是可以用final修饰
            3.作用域仅仅在定义他的方法或代码块中
            4.局部内部类--访问--->外部成员，直接访问
            5.外部类访问内部类成员，创建对象再访问，必须在作用域内
            6.外部其他类不能访问局部内部类
            7.如果外部类和局部内部类的成员重名时，就近原则，如果想访问的时外部类的成员，外部类名.this.成员
        匿名内部类 - 无类名，重点
            1.本质是类，2 内部类 3.该类没有名字 4.同时还是个对象
            //在底层系统会分配一个类名 xx$1
            //jdk底层创建了匿名内部类，马上就创建了其实例，类只能调用一次
            //参数列表会传递给构造器
            new 类或接口(参数列表){
                类体
            };
            调用可以直接调用，因为既是类的定义，也是对象的创建
            最佳实践：当作实参直接传递
    定义在外部类的成员位置上
        成员内部类 - 没有static修饰

        静态内部类 - 使用static修饰

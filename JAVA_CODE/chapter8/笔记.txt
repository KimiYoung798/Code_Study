面向对象编程中级部分
	intelliJ IDEA
	包
	访问修饰符
	封装
	继承
	多态
	Super
	overwrite
	Object类详解
	断点调试

IDEA
	集成开发工具
	以项目的概念管理原码
	快捷键
        1) 删除当前行, 默认是 ctrl + Y 自己配置 ctrl + d
        2) 复制当前行, 自己配置 ctrl + alt + 向下光标
        3) 补全代码 alt + /
        4) 添加注释和取消注释 ctrl + / 【第一次是添加注释，第二次是取消注释】
        5) 导入该行需要的类 先配置 auto import , 然后使用 alt+enter 即可
        6) 快速格式化代码 ctrl + alt + L
        7) 快速运行程序 自己定义 alt + R
        8) 生成构造器等 alt + insert [提高开发效率]
        9) 查看一个类的层级关系 ctrl + H [学习继承后，非常有用]
        10) 将光标放在一个方法上，输入 ctrl + B , 可以定位到方法 [学继承后，非常有用]
        11) 自动的分配变量名 , 通过 在后面假 .var [老师最喜欢的]
        12) 还有很多其它的快捷键...

包：
    包的本质就是创建不同的文件夹来保存类
    作用：
        1.区分相同名字的类
        2.当类很多时可以很好的管理类
        3.控制访问范围
    基本语法：
        package com.xxx.xxx;
        声明当前类所在的包，需要放在最上面，一个类中最多只有一句package
    包的命名：
        规则：只能包含数字、字母、下划线、小圆点，但是不能数字开头，不能是关键字或保留字
        规范：小写字母+小圆点
    常用包：
        1) java.lang.* //lang包是基本包，默认引入，不需要再引入.
        2) java.util.* //util包，系统提供的工具包, 工具类，使用 Scanner
        3) java.net.* //网络包，网络开发
        4) java.awt.* //是做 java的界面开发，GUI
    引入：
        import 包;
        *代表引入所有当前包内的类，不建议用
        位置在package下，在类定义前面，可以有多条且没有顺序要求

访问修饰符
    java 提供四种访问控制修饰符号，用于控制方法和属性(成员变量)的访问权限（范围）:
        1) 公开级别:用 public 修饰,对外公开
        2) 受保护级别:用 protected 修饰,对子类和同一个包中的类公开
        3) 默认级别:没有修饰符号,向同一个包的类公开.
        4) 私有级别:用 private 修饰,只有类本身可以访问,不对外公开.
    注意事项：
        修饰符可以用来修饰类中的属性，成员方法以及类
        只有默认和public才能修饰类，且遵循上述访问权限特点
        成员方法访问规则和属性完全一样

面向对象编程三大特征
    封装
        封装（encapsulation）把抽象出的数据和对数据的操作封装在一起，
        数据被保护在内部，程序的其他部分只有通过被授权的操作，才能对数据进行操作
        好处：
            隐藏实现细节
            可以对数据进行验证，保证安全合理
        实现步骤：
            1.将属性私有化private
            2.提供一个公共的set方法，用于对属性的判断并赋值
                public void setXxx(类型 参数名) {
                    //加入数据验证业务逻辑
                    属性 = 参数名;
                }
            3.提供一个公共的get方法，用于获取属性的值
                public 数据类型 getXxx() {
                    //加权限验证业务逻辑
                    return xx;
                }
            alt + insert
            构造器 + setXxx
    继承
        extends解决代码复用，当多个类存在相同的属性和方法时，
        可以从中抽象出父类，在父类中定义相同的属性和方法，
        所有子类不需要定义，通过extends来声明父类即可
        子类-父类 派生类-基类/超类
        优点：
            提高代码复用性
            代码的扩展性与维护性提高
        细节：
            1.子类继承了所有的属性和方法，但是私有属性和方法不能在子类中直接访问，要通过公共方法去访问
            2.子类必须调用父类的构造器完成对父类的初始化
            3.当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，
                如果父类没有提供无参构造器，则必须在子类的构造器中用 super 去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译器不会通过
            4.如果希望指定去调用父类的某个构造器，则显式的调用一下 : super(参数列表)
            5.super 在使用时，必须放在构造器第一行(super 只能在构造器中使用)
            6.super() 和 this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器
            7.java 所有类都是 Object 类的子类, Object 是所有类的基类.
            8.父类构造器的调用不限于直接父类！将一直往上追溯直到 Object 类(顶级父类)
            9.子类最多只能继承一个父类(指直接继承)，即 java 中是单继承机制。
                思考：如何让 A 类继承 B 类和 C 类？ 【A 继承 B， B 继承 C】
            10) 不能滥用继承，子类和父类之间必须满足 is-a 的逻辑关系
        继承的本质：
            当子类对象创建好之后，建立查找关系
            按照查找关系来返回信息
            (1) 首先看子类是否有该属性
            (2) 如果子类有这个属性，并且可以访问，则返回信息
            (3) 如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性，并且可以访问，就返回信息..)
            (4) 如果父类没有就按照(3)的规则，继续找上级父类，直到 Object..

        super关键字
            代表父类的一个引用，用于访问父类属性、方法、构造器
            细节：
                1.不能访问父类private的属性
                2.不能访问父类private的方法
                3.访问父类构造器，只能放在构造器的第一句

        方法重写/覆盖 override
            子类中的方法与父类方法名称、返回类型、参数一样，那么就称子类这个方法覆盖了父类的方法

            细节：
                1. 子类中的方法与父类方法名称、参数一样
                2. 子类的返回类型和父类的返回类型，或者是父类返回类型的子类，
                    例如：父类中Object  子类中是String，反之不行
                3. 子类方法不能缩小父类访问权限

    多态polymorphic
        提高代码复用性，多[多态]态[状态]，方法或对象具有多种形态
        1.方法重载和重写就是一种多态
        2.对象的多态
            1) 一个对象的编译类型和运行类型可以不一致，父类的引用可以指向子类的对象
            2) 编译类型在定义对象是，就确定了，不能改变
            3) 运行类型是可以变化的
            4) 编译类型看定义时看 = 左边，运行类型看 = 右边

            细节
                多态前提是两个对象是继承关系，
                多态是向上转型，本质就是父类引用指向了子类的对象
                语法： 父类类型 引用名 = new 子类类型();
                    思考，Object obj = new Cat();
                特点：
                    编译类型看定义时看 = 左边，运行类型看 = 右边
                    可以调用父类所有成员(须遵守访问权限)，
                    不能调用子类中特有成员，//能调用哪些成员，是由编译类型来决定的
                    最终运行效果看子类的具体实现 //编译是从Object到父类结束，运行是从本类开始
                向下转型：
                    语法： 子类类型 引用名 = (子类类型)父类引用 Cat cat = (cat) animal
                    只能强转父类的引用，不能强转父类的对象
                    之恶能要求父类的引用必须指向的是当前目标类型的对象
                    可以调用子类类型中所有的成员
                属性没有重写之说，属性的值看编译类型
                instanceOf比较操作符，判断对象的运行类型是否是xx类型或xx类型的子类

            动态绑定机制（非常重要）dynamic
                1.当调用对象方法的时候，该方法会和该对象的内存地址/运行类型绑定
                2.当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用

        多态数组
            数组的定义类型为父类类型，里面保存的实际元素为子类类型
        多态参数
            方法定义的形参类型为父类类型，实参允许为子类类型

Object类详解
    equals方法
        ==和equals比较
            == 是一个比较运算符
                1.既可以判断基本类型，也可以判断引用类型
                2.判断基本类型就是判断值是否相等
                3.判断引用类型就是判断地址是否相等
            equals
                1.是一个Object类中的一个方法，只能判断引用类型
                2.默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等
        如何重写：
            重写就完事了
    hashCode
        1.提高具有hash结构的容器的效率
        2.两个引用，如果指向的是同一个对象，则hash值肯定是一样的
        3.两个引用，如果指向的是不同对象，则hash值是不一样的
        4.hash值主要根据地址号计算的，不能完全将hash值等价地址
        5.有需要，也会重写
    toString
        默认返回：getClass().getName() + "@" + Integer.toHexString(hashCode()) 将hashcode值转成16进制
        重写toString，打印对象或拼接对象
        当输出一个对象时，toString方法会被默认调用
    finalize
        1.当对象被回收时，系统自动调用该对象的finalize方法，子类可以重写该方法，做一些释放资源操作
        2.什么时候回收：当某个对象没有任何引用时，jvm默认这个对象是个垃圾对象，就会使用垃圾回收机制销毁该对象，在销毁该对象前，对先调用finalize方法
        3.垃圾回收机制的调用，是由系统决定的，也可以通过System.gc()主动触发垃圾回收机制


断点调试
    1.断点调试是指在程序的某一行设置一个断点，调试时，程序运行至至一行会停住，然后可以一步一步往下调试，调试过程中可以看各个变量当前值，调试时会结束在出错的地方，停下。
    2.断点调试是程序员必备技能
    3.断点调试可以帮我们查看java底层代码的执行过程，提高程序员水平